#include "Game.h"

#include "Core/Common/Vector2.h"
#include "Core/Common/Vector3.h"
#include "Core/Graphics/VertexTypes/VertexPosition.h"
#include "Core/Graphics/VertexTypes/VertexPositionLayout.h"

#include "Core/Components/RenderComponent.h"
#include "Core/Services/RenderService.h"

#include <fmt/core.h>

void testFunc()
{
    fmt::print("Test!");
}

namespace Ceres
{
    Game::Game()
    {
    }

    Game::~Game()
    {
    }

    bool Game::Initialize()
    {
        ServiceContainer.AddService("render", new RenderService(GraphicsDevice));
        InputHandler.BindInput(Button::Key_space, &testFunc);
        InputHandler.BindAxis("test", Button::Key_up, Button::Key_down, Button::Key_left, Button::Key_right);

        return true;
    }

    void Game::Load()
    {
        // Example for current mesh loading code:
        // Loads a cube!

        VertexPosition verts[] = {
            Vector3(-1, -1, 1), Vector3(-1, 1, 1), Vector3(1, 1, 1), Vector3(1, -1, 1),
            Vector3(-1, -1, -1), Vector3(-1, 1, -1), Vector3(1, 1, -1), Vector3(1, -1, -1)};
        unsigned int indices[] = {
            0, 1, 2, 0, 2, 3,
            4, 5, 6, 4, 6, 7,
            1, 2, 5, 2, 5, 6,
            0, 3, 4, 3, 4, 7,
            0, 1, 4, 1, 4, 5,
            2, 3, 6, 3, 6, 7
        };

        // Store the meshId, which is generated by whatever class
        // manages the mesh loading.
        // For now, that is just the GraphicsDevice
        uint8_t meshId = GraphicsDevice.LoadMesh(verts, VertexPositionLayout(), 8, indices, 36);

        // Transforms can be set from each individual aspect,
        // position/translation, rotation, and scale.
        // This avoids having to calculate reverse transform matrices
        // or trying to solve rotation angles from a matrix.

        ServiceContainer.GetService("render")->GenerateComponent("RenderComponent", 1, &meshId);
        // _graphicsDevice.GetRenderComponent(_testRender).Transform.SetScale(Vector3(1, 4, 1));
    }

    void Game::Update(double seconds)
    {
        seconds += 0;
        /* Vector2 inputAxis = InputHandler.GetAxisValue("test");
        inputAxis.X = inputAxis.X * (float) seconds * 10;
        inputAxis.Y = inputAxis.Y * (float) seconds * 10;
        Vector3 newPos = _graphicsDevice.GetRenderComponent(_testRender).Transform.GetPosition();
        _graphicsDevice.GetRenderComponent(_testRender).Transform.SetPosition(Vector3(newPos.X + inputAxis.X, newPos.Y, newPos.Z - inputAxis.Y)); */
    }

    void Game::Draw()
    {
        // _graphicsDevice.Render();
        ((RenderService*) ServiceContainer.GetService("render"))->RenderComponents();
    }
}